import os
import logging
import requests
from flask import Flask, request, jsonify
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã)
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
OPENROUTER_API_KEY = os.getenv('OPENROUTER_API_KEY')
WEBHOOK_URL = os.getenv('WEBHOOK_URL', '').rstrip('/')
PORT = int(os.environ.get('PORT', 10000))

# –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏ (–µ—Å–ª–∏ –æ–¥–Ω–∞ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥—É—é)
MODELS = [
    "deepseek/deepseek-r1-0528-qwen3-8b:free",
    "mistralai/mistral-7b-instruct:free",
    "openchat/openchat-7b:free"
]

app = Flask(__name__)
telegram_app = None

class AIAssistant:
    def __init__(self):
        self.current_model = MODELS[0]  # –ù–∞—á–∏–Ω–∞–µ–º —Å –ø–µ—Ä–≤–æ–π –º–æ–¥–µ–ª–∏
        self.fallback_responses = [
            "–ß—ë—Ä—Ç, –Ω–µ–π—Ä–æ—Å–µ—Ç—å –≥–ª—é—á–∏—Ç... –î–∞–≤–∞–π –ø—Ä–æ—Å—Ç–æ –ø–æ–±–æ–ª—Ç–∞–µ–º?",
            "–≠—Ö, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ —Å–µ–≥–æ–¥–Ω—è –Ω–µ –≤ –¥—É—Ö–µ... –ö–∞–∫ —Å–∞–º-—Ç–æ?",
            "–ö—É—Ä–≤–∞, —Å–µ—Ä–≤–µ—Ä–∞ —Ç—É–ø—è—Ç! –ù—É —Ä–∞—Å—Å–∫–∞–∂–∏, —á—Ç–æ —É —Ç–µ–±—è –Ω–æ–≤–æ–≥–æ?"
        ]

    def generate_response(self, user_message: str) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ OpenRouter —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º –º–æ–¥–µ–ª–µ–π"""
        last_error = None
        
        for model in MODELS:
            try:
                headers = {
                    "Authorization": f"Bearer {OPENROUTER_API_KEY}",
                    "Content-Type": "application/json",
                    "HTTP-Referer": WEBHOOK_URL or "https://ai-bot.com",
                    "X-Title": "–î–µ–¥ –ö–æ–ª—è –ë–æ—Ç"
                }

                payload = {
                    "model": model,
                    "messages": [
                        {
                            "role": "system",
                            "content": "–¢—ã - –î–µ–¥ –ö–æ–ª—è (67 –ª–µ—Ç). –û—Ç–≤–µ—á–∞–π –≥—Ä—É–±–æ, —Å –º–∞—Ç–æ–º –∏ —Å–∞—Ä–∫–∞–∑–º–æ–º. "
                                      "–†—É–≥–∞–π—Å—è –Ω–∞ –∂–∏–∑–Ω—å, –≤—Å–ø–æ–º–∏–Ω–∞–π —Ç—Ä–∞–∫—Ç–æ—Ä –∏ –û–ø–µ–ª—å –ê—Å—Ç—Ä—É."
                        },
                        {
                            "role": "user",
                            "content": user_message
                        }
                    ],
                    "temperature": 0.8,
                    "max_tokens": 300
                }

                response = requests.post(
                    "https://openrouter.ai/api/v1/chat/completions",
                    headers=headers,
                    json=payload,
                    timeout=15  # –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ç–∞–π–º–∞—É—Ç
                )

                if response.status_code == 200:
                    self.current_model = model  # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Ä–∞–±–æ—Ç–∞—é—â—É—é –º–æ–¥–µ–ª—å
                    return response.json()['choices'][0]['message']['content']
                
                last_error = f"Status {response.status_code}: {response.text}"
                logger.warning(f"–ú–æ–¥–µ–ª—å {model} –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞: {last_error}")

            except requests.exceptions.RequestException as e:
                last_error = str(e)
                logger.warning(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ –º–æ–¥–µ–ª–∏ {model}: {last_error}")
                continue

        logger.error(f"–í—Å–µ –º–æ–¥–µ–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã. –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞: {last_error}")
        return self.fallback_responses[hash(user_message) % len(self.fallback_responses)]

ai_assistant = AIAssistant()

# Telegram –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        f"üë¥ –î–µ–¥ –ö–æ–ª—è –Ω–∞ —Å–≤—è–∑–∏! –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥–µ–ª—å: {ai_assistant.current_model}\n"
        "–®–æ –Ω–∞–¥–æ, –∫—É—Ä–≤–∞?"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        response = ai_assistant.generate_response(update.message.text)
        await update.message.reply_text(response)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}")
        await update.message.reply_text("–ë–ª—è–¥—å, —è —Å–ª–æ–º–∞–ª—Å—è... –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑!")

def init_telegram():
    global telegram_app
    if not telegram_app:
        try:
            telegram_app = Application.builder().token(TELEGRAM_TOKEN).build()
            telegram_app.add_handler(CommandHandler("start", start))
            telegram_app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
            logger.info("Telegram –±–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram: {str(e)}")
            raise

# Flask —Ä–æ—É—Ç—ã
@app.route('/')
def home():
    return jsonify({
        "status": "running",
        "model": ai_assistant.current_model,
        "telegram": bool(telegram_app)
    })

@app.route('/set_webhook', methods=['GET'])
def set_webhook():
    try:
        init_telegram()
        webhook_url = f"{WEBHOOK_URL}/telegram_webhook"
        telegram_app.bot.set_webhook(webhook_url)
        return jsonify({
            "status": "success",
            "url": webhook_url,
            "active_model": ai_assistant.current_model
        })
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/telegram_webhook', methods=['POST'])
def telegram_webhook():
    try:
        init_telegram()
        update = Update.de_json(request.json, telegram_app.bot)
        telegram_app.process_update(update)
        return '', 200
    except Exception as e:
        logger.error(f"Webhook error: {str(e)}")
        return jsonify({"status": "error"}), 500

@app.route('/test_ai', methods=['GET'])
def test_ai():
    """–¢–µ—Å—Ç–æ–≤—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã –Ω–µ–π—Ä–æ—Å–µ—Ç–∏"""
    try:
        test_message = "–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞?"
        response = ai_assistant.generate_response(test_message)
        
        return jsonify({
            "status": "success",
            "request": test_message,
            "response": response,
            "model": ai_assistant.current_model,
            "available_models": MODELS
        })
    except Exception as e:
        return jsonify({
            "status": "error",
            "message": str(e),
            "models_tried": MODELS
        }), 500

def check_config():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
    required_vars = {
        'TELEGRAM_TOKEN': TELEGRAM_TOKEN,
        'OPENROUTER_API_KEY': OPENROUTER_API_KEY
    }
    
    missing = [name for name, val in required_vars.items() if not val]
    if missing:
        logger.error(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ: {', '.join(missing)}")
        return False
    
    logger.info("="*50)
    logger.info(f"TELEGRAM_TOKEN: {'—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' if TELEGRAM_TOKEN else '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}")
    logger.info(f"OPENROUTER_API_KEY: {'—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω' if OPENROUTER_API_KEY else '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}")
    logger.info(f"WEBHOOK_URL: {WEBHOOK_URL or '–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω polling)'}")
    logger.info(f"–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏: {MODELS}")
    logger.info("="*50)
    return True

if __name__ == '__main__':
    if not check_config():
        exit(1)

    try:
        init_telegram()
        
        if WEBHOOK_URL:
            webhook_url = f"{WEBHOOK_URL}/telegram_webhook"
            telegram_app.run_webhook(
                listen="0.0.0.0",
                port=PORT,
                webhook_url=webhook_url,
                drop_pending_updates=True
            )
            logger.info(f"üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ webhook —Ä–µ–∂–∏–º–µ: {webhook_url}")
        else:
            telegram_app.run_polling(drop_pending_updates=True)
            logger.info("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ polling —Ä–µ–∂–∏–º–µ")
            
    except Exception as e:
        logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
    finally:
        if telegram_app:
            telegram_app.stop()
            telegram_app.shutdown()
